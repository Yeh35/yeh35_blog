%{
title: "어떤 mysql id로 어떤 것을 사용해야하지 2de4432787e942e3b24a1a6c94108a88.md",
author: "yeh35",
tags: ~w(dev),
description: "",
published: false
}
---
# 어떤 mysql id로 어떤 것을 사용해야하지?

게시: No
생성일자: 2022년 12월 27일 오후 1:56
수정일자: 2023년 1월 20일 오후 2:01
태그: DB, UUID, mysql

DB id로 UUID를 선택할 생각 했다면 그 이유는 너무 많은 글에서 설명하니 생략하고, UUID를 적용하기 위한 방법론을 다룰 생각이다. 
여기서 적용되는 환경은 `MYSQL 8.0`, `JPA` 이지만 여기서 고민한 것을 

# **TL;DR**

1. 신규 시스템이면 UUID를 DB ID로 쓰세요 두번 쓰세요.
2. UUID에 대해서 더 자세히 알고 싶다면 [어떤 mysql id로 어떤 것을 사용해야하지?](%E1%84%8B%E1%85%A5%E1%84%84%E1%85%A5%E1%86%AB%20mysql%20id%E1%84%85%E1%85%A9%20%E1%84%8B%E1%85%A5%E1%84%84%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A2%E1%84%8B%E1%85%A3%E1%84%92%E1%85%A1%E1%84%8C%E1%85%B5%202de4432787e942e3b24a1a6c94108a88.md) 
3. 바로, JPA에 적용한 코드가 보고 싶다면 [실무에서 ID 값으로 UUID 사용하기 with JPA](%E1%84%89%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5%20ID%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20UUID%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20with%20JPA%2095288cce411f44f1a91ef7b94ddc7716.md) 

# 들어가며

스타트업에서 백엔드 시스템을 새롭게 구축하면서 확장성과 편의성(?) 사이를 줄타기하며 개발을 진행하였습니다.
확장성을 위해 편의성을 포기할때는 다음과 같은 규칙을 세웠습니다.
`“나중에 변경하기 매우 힘들거나, 불가능한 것에는 합의를 두지 말자”`

이런 것에는 무엇이 있을까? 바로 `ID 값`입니다.
사실상 ID는 한번 만들어지면 Client에서도 사용되고, 나중에 외부 시스템에서도 사용될 수 있어서 변경이 사실상 불가능한 존재가 되어버립니다.

결론은 ID 값을 UUID로 결정하기까지 고민했던 내용을 이야기 해보려고 합니다.

# 요구사항

- [ ]  값이 예측 불가능해야한다.
- [ ]  어디서나 언제나 고유해야한다.
- [ ]  DB가 늘어나고, RDB에서 NoSQL로 바뀌어도 유효해야한다.

## 지금은 MySQL 하나지만…

간단하지만 하나 하나 묵직한 요구사항들입니다.

현재 DB는 mysql 하나만 사용합니다. 일단 초기라서 트레픽도 없고 기능을 찍어내듯 만들어야하는 상황에서 여러 종류의 데이터 베이스를 사용하는 것은 오버엔지니어링이라고 생각합니다.

미래에는 유저도 많이 많이 늘어나 MYSQL만으로 감당이 안될 때는 NoSQL로 분리를 해야합니다.

![Untitled](/images/posts/0a712e79-1e96-4573-8376-72320d83de95.png)

# ID로 사용할 만한 것들

## Long : MySQL auto_increment

ID 값을 생각하면 `auto_increment`로 생성한 Long Type이 생각이 났습니다.
하지만 첫 번째 요구사항인 `“값이 예측 불가능해야한다."`의해서 바로 폐기했습니다.

## [Snowflake](https://en.wikipedia.org/wiki/Snowflake_ID) **ID**

![Untitled](/images/posts/67a1cf42-5f8d-471b-a8b9-f2f5e23b8bfd.png)

Twitter에서 만들고 사용하고 있다는 분산 ID 생성 방식입니다.
64bit로 long type과 크기가 동일해서 DB에 저장할 때도 편하고, 가져다 쓰기도 편합니다.
심지어 다음 값을 예측하는 것도 쉽지 않습니다.

개인적으로 느낀 장단점을 적어보면

### 장점

- 레거시가 long type으로 되어 있는 경우에 쉽게 적용할 수 있습니다.
- 시간 + 인스턴스로 의미 있는 ID를 만들 수 있습니다.
- 값을 예측할 수 없습니다.
- 언제 어디서나 고유하게 생성할 수 있습니다.

### 단점

- 각 언어들에서 기본적으로 지원을 안함으로 직접 만들어서 써야한다.
그것도 잘.. 만들어서 써야합니다.
- timestamp 길이가 41 bit로 약 69년 뒤에는 사용할 수 없습니다.
    
    <aside>
    📌 timestamp = (unix time - 채번  시작 시간)로 들어간다.
    
    </aside>
    
- 시스템의 시간대에 의존하게 됩니다.
- 인터넷 표준은 아닙니다.
- JavaScript에서는 Number Type이 사실상 실수형이라서 아니라 String으로 처리해야합니다. 
(하 또 JS가..)

## UUID v1

사실 아마 요구사항을 보자마자 바로 UUID가 떠올랐을 것입니다.

개인적인 UUID에 장단점도 정리해보면

### 장점

- 인터넷 표준으로 대부분의 언어와 DataBase에서 기본적으로 제공합니다.
- 값을 예측할 수 없습니다.
- 언제 어디서나 고유하게 생성할 수 있습니다.
- UUID v1을 사용하면 언제 어디서 생성되었는지 알 수 있습니다.

### 단점

- 기존 정수형 type으로 된 레거시 시스템이 있다면 마이그레이션에 많은 리소스가 필요 합니다.
- 128 bit라는 long 보다는 2배 큽니다.
- UUID도 JS에서 UUID type이 있는 것이 아니라서 String으로 처리해야합니다.
- MySQL에서 사용시 커스텀이 필요합니다.
- 시스템의 시간대에 의존하게 됩니다.

# 결론

그 외의 다양한 ID 방식들을 찾아봤지만 보면 볼 수록 UUID v1가 적합하다는 생각이 들었습니다.

1. 신규 시스템으로 마이그레이션 해줘야하는 ID가 없습니다.
2. 128bit가 Long(64bit)에 비해서 큰 것이지 이정도는 무시할 수 있는 수준이라고 생각합니다.
3. `Snowflake`는 스펙에 맞게 직접 구현해줘야하는데 반해서 대부분에 언어에서 기본적으로 UUID 생성기를 지원합니다.
4. RFC에서 제안된 표준(Proposed Standard)으로 값 생성에 대한 검증은 믿을 수 있다.
    
    ![Untitled](/images/posts/931d13fc-63de-457b-8b15-a4ed33aa93cd.png)
    

## 이어서…

앞에 장단점에서도 언급은 했지만 UUID 값을 그대로 사용할 수 없습니다.
MySQL Key로써 UUID를 사용하기 위해서는 몇가지 커스텀한 절차가 필요하다. 
다음 글에서는 UUID를 톺아보면서 ID 값으로 사용하는 방법을 고민해보자!

# 자료

- [UUID RFC 스펙 문서](https://www.rfc-editor.org/search/rfc_search_detail.php?title=uuid&pubstatus%5B%5D=Any&pub_date_type=any)
- [Snowflake](https://en.wikipedia.org/wiki/Snowflake_ID) 위키
- [UUID  Ssup2 Blog, UUID 설명이 잘되어 있는 한국어 블로그](https://ssup2.github.io/theory_analysis/UUID/)
- **[분산 처리 시스템에서 유일한 식별자를 만드는 방법(twitter snowflake)](https://jeong-pro.tistory.com/251)**